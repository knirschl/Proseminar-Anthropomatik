\section{Implementierung}
\label{impl}
\begin{figure*}[htb!]
    \centering
    \begin{subfigure}[b]{.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{pdf_plots/idf2_log-sin_iu500c-RND.pdf}
        \caption{Eingabewerte zufällig generiert mit \code{random}}
        \label{fig:logsin_random}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{pdf_plots/idf2_log-sin_iu500c-GRS.pdf}
        \caption{Eingabewerte aus einer Goldenen Schnitt Sequenz}
        \label{fig:logsin_uniform}
    \end{subfigure}
    \caption{$500$ Punkte mit einer logistischen Dichte auf der X- und einer sinusoiden auf der Y-Achse}
    \label{fig:rand_vs_uniform}
\end{figure*}


Um einen Eindruck der hashbasierten Inversionsmethode und ihrer Arbeitsweise zu bekommen, 
wird jetzt eine konkrete Implementierung dieser angesprochen und Ergebnisse bei 
unterschiedlichen Eingaben gezeigt. Geschrieben wurde das Programm in Python mithilfe der 
Pakete \textit{numpy} und \textit{matplotlib}.

Schretter \cite{schretter-golden_ratio_sequences-2012} stellt am Ende der Arbeit eine 
C++-Methode zur Generierung einer zweidimensionalen Goldenen-Schnitt-Sequenz zur Verfügung. 
Diese Methode wurde in ein Python-Script übertragen und alle, in diesem Kapitel erwähnte, zufällige, uniformen
Variablen $U$ werden mit diesem Script generiert.

Zum Testen der vorgestellten Methode wurde das Konzept von Chen und Asau \cite{chen_asau-generating_random_variates-1974} 
implementiert. Dabei wurde kein großer Wert auf optimale Laufzeiten gelegt, sondern darauf, eine Demonstration 
des Verfahrens geben zu können.

% TODO
% Ergebnisse bei unterschiedlichen Werten auswerten nicht nur im Bild
\dots


